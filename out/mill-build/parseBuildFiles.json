{
    "value": {
        "seenScripts": [
            [
                "/home/runner/work/Ammonite/Ammonite/ci/upload.sc",
                "\ndef apply(\n    uploadedFile: os.Path,\n    tagName: String,\n    uploadName: String,\n    authKey: String,\n    ghOrg: String,\n    ghRepo: String\n): String = {\n  println(\"upload.apply\")\n  println(uploadedFile)\n  println(tagName)\n  println(uploadName)\n  println(authKey)\n  println(ghOrg)\n  println(ghRepo)\n  val body = requests.get(\n    s\"https://api.github.com/repos/${ghOrg}/${ghRepo}/releases/tags/\" + tagName,\n    headers = Seq(\"Authorization\" -> s\"token $authKey\")\n  )\n\n  val parsed = ujson.read(body.text)\n\n  println(body)\n\n  val snapshotReleaseId = parsed(\"id\").num.toInt\n\n  val uploadUrl =\n    s\"https://uploads.github.com/repos/${ghOrg}/${ghRepo}/releases/\" +\n      s\"$snapshotReleaseId/assets?name=$uploadName\"\n\n  val res = requests.post(\n    uploadUrl,\n    headers = Seq(\n      \"Content-Type\" -> \"application/octet-stream\",\n      \"Authorization\" -> s\"token $authKey\"\n    ),\n    connectTimeout = 5000,\n    readTimeout = 60000,\n    data = os.read.bytes(uploadedFile)\n  ).text\n\n  println(res)\n\n  val longUrl = ujson.read(res)(\"browser_download_url\").str\n\n  longUrl\n}\n"
            ],
            [
                "/home/runner/work/Ammonite/Ammonite/build.sc",
                "// plugins\nimport _root_._\nimport _root_._\nimport millbuild.ci.upload\n// imports\nimport java.util.concurrent.atomic.AtomicInteger\nimport scala.concurrent.{Await, ExecutionContext, Future, duration}\nimport scala.util.chaining.scalaUtilChainingOps\nimport coursier.mavenRepositoryString\nimport mill._\nimport mill.api.Result\nimport mill.contrib.bloop.Bloop\nimport mill.define.Command\nimport mill.main.Tasks\nimport mill.scalalib._\nimport mill.scalalib.publish._\nimport mill.scalalib.api.ZincWorkerUtil._\nimport mill.testrunner.TestRunner\n\nval ghOrg = \"com-lihaoyi\"\nval ghRepo = \"Ammonite\"\nval masterBranch = \"main\"\nval publishBranches = Seq(masterBranch, \"2.x\")\nval homePage = \"https://ammonite.io\"\n\nval isMasterCommit =\n  sys.env.get(\"GITHUB_REPOSITORY\") == Some(s\"${ghOrg}/${ghRepo}\") &&\n    sys.env.get(\"GITHUB_REF\").exists(x => x.endsWith(s\"/${masterBranch}\"))\n\nval isPublishableCommit =\n  sys.env.get(\"GITHUB_REPOSITORY\") == Some(s\"${ghOrg}/${ghRepo}\") &&\n    sys.env.get(\"GITHUB_REF\").exists(x =>\n      publishBranches.exists(suffix => x.endsWith(s\"/${suffix}\"))\n    )\n\nval latestTaggedVersion = os.proc(\"git\", \"describe\", \"--abbrev=0\", \"--tags\").call().out.trim\n\nval gitHead = os.proc(\"git\", \"rev-parse\", \"HEAD\").call().out.trim\n\nval commitsSinceTaggedVersion = {\n  os.proc(\"git\", \"rev-list\", gitHead, \"--not\", latestTaggedVersion, \"--count\")\n    .call()\n    .out\n    .trim\n    .toInt\n}\n\n//val isJava21 = scala.util.Properties.isJavaAtLeast(21).tap {\n//  if (_) println(\"Java 21+: Skip building of modules requiring incompatible Scala versions\")\n//}\n\nval scala2_12Versions = 9.to(19)\n//  .dropWhile(v => isJava21 && v < 18)\n  .map(v => s\"2.12.${v}\")\nval scala2_13Versions = 2.to(14)\n//  .dropWhile(v => isJava21 && v < 11)\n  .map(v => s\"2.13.${v}\")\nval scala33Versions = Seq(\"3.3.0\", \"3.3.1\", \"3.3.2\", \"3.3.3\")\n//  .dropWhile(v => isJava21 && v == \"3.3.0\")\nval scala34Versions = Seq(\"3.4.2\")\n\nval scala2Versions = scala2_12Versions ++ scala2_13Versions\nval scala3Versions = scala33Versions ++ scala34Versions\n\nval binCrossScalaVersions =\n  Seq(scala2_12Versions.last, scala2_13Versions.last, scala33Versions.last)\nval assemblyCrossScalaVersions =\n  Seq(scala2_12Versions.last, scala2_13Versions.last, scala33Versions.last, scala34Versions.last)\ndef isScala2_12_10OrLater(sv: String): Boolean = {\n  (sv.startsWith(\"2.12.\") && sv.stripPrefix(\"2.12.\").length > 1) || sv.startsWith(\"2.13.\")\n}\nval fullCrossScalaVersions = scala2Versions ++ scala3Versions\n\nval latestAssemblies = assemblyCrossScalaVersions.map(amm(_).assembly)\n\nprintln(\"GITHUB REF \" + sys.env.get(\"GITHUB_REF\"))\n\nval (buildVersion, unstable) = scala.util.Try(\n  os.proc(\"git\", \"describe\", \"--exact-match\", \"--tags\", \"--always\", gitHead)\n    .call()\n    .out\n    .trim\n).toOption match {\n  case None =>\n    val gitHash = os.proc(\"git\", \"rev-parse\", \"--short\", \"HEAD\").call().out.trim\n    (s\"$latestTaggedVersion-$commitsSinceTaggedVersion-$gitHash\", true)\n  case Some(tagName) => (tagName, false)\n}\n\nval bspVersion = \"2.1.0-M5\"\nval fastparseVersion = \"3.1.1\"\nval scalametaVersion = \"4.9.7\"\n\nobject Deps {\n  val acyclic = ivy\"com.lihaoyi:::acyclic:0.3.12\"\n  val bsp4j = ivy\"ch.epfl.scala:bsp4j:${bspVersion}\"\n  val bcprovJdk15on = ivy\"org.bouncycastle:bcprov-jdk18on:1.78.1\"\n  val cask = ivy\"com.lihaoyi::cask:0.9.1\"\n  val classPathUtil = ivy\"io.get-coursier::class-path-util:0.1.4\"\n  val coursierInterface = ivy\"io.get-coursier:interface:1.0.19\"\n  val coursierDependencyInterface = ivy\"io.get-coursier::dependency-interface:0.2.3\"\n  val fansi = ivy\"com.lihaoyi::fansi:0.5.0\"\n  val fastparse = ivy\"com.lihaoyi::fastparse:$fastparseVersion\"\n  val geny = ivy\"com.lihaoyi::geny:1.1.1\"\n  val javaparserCore = ivy\"com.github.javaparser:javaparser-core:3.2.12\"\n  val javassist = ivy\"org.javassist:javassist:3.21.0-GA\"\n  val jlineJna = ivy\"org.jline:jline-terminal-jna:3.14.1\"\n  val jlineReader = ivy\"org.jline:jline-reader:3.14.1\"\n  val jlineTerminal = ivy\"org.jline:jline-terminal:3.14.1\"\n  val jsch = ivy\"com.jcraft:jsch:0.1.55\"\n  val mainargs = ivy\"com.lihaoyi::mainargs:0.5.4\"\n  val osLib = ivy\"com.lihaoyi::os-lib:0.10.6\"\n  val pprint = ivy\"com.lihaoyi::pprint:0.9.0\"\n  val requests = ivy\"com.lihaoyi::requests:0.8.3\"\n  val scalacheck = ivy\"org.scalacheck::scalacheck:1.18.0\"\n  val scalaCollectionCompat = ivy\"org.scala-lang.modules::scala-collection-compat:2.12.0\"\n  def scalaCompiler(scalaVersion: String) = ivy\"org.scala-lang:scala-compiler:${scalaVersion}\"\n  val scalaJava8Compat = ivy\"org.scala-lang.modules::scala-java8-compat:1.0.2\"\n  val scalaparse = ivy\"com.lihaoyi::scalaparse:$fastparseVersion\"\n  def scalaReflect(scalaVersion: String) = ivy\"org.scala-lang:scala-reflect:${scalaVersion}\"\n  def scalaXml(sv: String) = {\n    val ver =\n      if (sv.startsWith(\"2.12.\")) \"1.3.0\"\n      else \"2.0.1\"\n    ivy\"org.scala-lang.modules::scala-xml:$ver\"\n  }\n  val scalazCore = ivy\"org.scalaz::scalaz-core:7.2.36\"\n  val semanticDbScalac = ivy\"org.scalameta:::semanticdb-scalac:$scalametaVersion\"\n  val shapeless = ivy\"com.chuusai::shapeless:2.3.3\"\n  val slf4jNop = ivy\"org.slf4j:slf4j-nop:1.7.36\"\n  val sourcecode = ivy\"com.lihaoyi::sourcecode:0.4.2\"\n  val sshdCore = ivy\"org.apache.sshd:sshd-core:1.2.0\"\n  val scalametaCommon = ivy\"org.scalameta::common:$scalametaVersion\"\n  val typename = ivy\"org.tpolecat::typename:1.1.0\"\n  def upickle(sv: String) = {\n    val ver =\n      if (sv.startsWith(\"3.2.\")) \"3.1.0\"\n      else \"3.1.3\"\n    ivy\"com.lihaoyi::upickle:$ver\"\n  }\n  val utest = ivy\"com.lihaoyi::utest:0.8.3\"\n}\n\ntrait AmmInternalModule extends CrossSbtModule with Bloop.Module {\n  // We need it to be a Boolean, not T[Boolean]\n  def isCrossFullScalaVersion: Boolean = false\n  def crossFullScalaVersion = T { isCrossFullScalaVersion }\n  def skipBloop = {\n    val versions =\n      if (isCrossFullScalaVersion) assemblyCrossScalaVersions else binCrossScalaVersions\n    // no need to expose the modules for old Scala versions support in Bloop / Metals\n    !versions.contains(crossScalaVersion)\n  }\n  def artifactName = T {\n    \"ammonite-\" + millOuterCtx.segments.parts.mkString(\"-\").stripPrefix(\"amm-\")\n  }\n  def isScala2 = T { scalaVersion().startsWith(\"2.\") }\n  def scalacOptions = T {\n    if (isScala2()) Seq(\"-P:acyclic:force\")\n    else Nil\n  }\n  def compileIvyDeps = T {\n    if (isScala2()) Agg(Deps.acyclic)\n    else Agg[Dep]()\n  }\n  def scalacPluginIvyDeps = T {\n    if (isScala2()) Agg(Deps.acyclic)\n    else Agg[Dep]()\n  }\n  override def scalaLibraryIvyDeps = T {\n    val scalaV = scalaVersion()\n    val scalaO = scalaOrganization()\n    if (isScala3(scalaV)) Agg(\n      ivy\"$scalaO::scala3-library:$scalaV\"\n    )\n    else Agg(\n      ivy\"$scalaO:scala-library:$scalaV\"\n    )\n  }\n  trait AmmTests extends super.Tests with TestModule.Utest {\n    def ivyDeps = super.ivyDeps() ++ Agg(Deps.utest)\n    def forkArgs = Seq(\"-Xmx2g\", \"-Dfile.encoding=UTF8\")\n  }\n  def allBoundIvyDeps = T { transitiveIvyDeps() ++ scalaLibraryIvyDeps().map(bindDependency()) }\n  def sources = T.sources {\n    val sv = scalaVersion()\n    val extraDir =\n      if (sv.startsWith(\"2.12.\")) {\n        val patch = sv.stripPrefix(\"2.12.\").takeWhile(_.isDigit).toInt\n        val dirName0 = if (patch <= 8) \"scala-2.12.0_8\" else \"scala-2.12.9+\"\n        val dirNames1 = if (patch <= 12) Seq(\"scala-2.12.0_12\") else Nil\n        val dirNames = Seq(dirName0) ++ dirNames1\n        dirNames.map(dirName => PathRef(millSourcePath / \"src\" / \"main\" / dirName))\n      } else\n        Nil\n\n    val extraDir2 =\n      if (isScala2())\n        Seq(PathRef(\n          if (isScala2_12_10OrLater(sv)) millSourcePath / \"src\" / \"main\" / \"scala-2.12.10-2.13.1+\"\n          else millSourcePath / \"src\" / \"main\" / \"scala-not-2.12.10-2.13.1+\"\n        ))\n      else Nil\n    val extraDir3 =\n      if (isScala2()) {\n        val dir =\n          if (\n            sv.startsWith(\"2.13.\") && sv.stripPrefix(\"2.13.\").toInt >= 1 && sv.stripPrefix(\n              \"2.13.\"\n            ).toInt <= 11\n          )\n            millSourcePath / \"src\" / \"main\" / \"scala-2.13.1-2.13.11\"\n          else if (sv.startsWith(\"2.13.\") && sv.stripPrefix(\"2.13.\").toInt >= 12)\n            millSourcePath / \"src\" / \"main\" / \"scala-2.13.12+\"\n          else if (sv.startsWith(\"2.12.\") && sv.stripPrefix(\"2.12.\").toInt >= 13)\n            millSourcePath / \"src\" / \"main\" / \"scala-2.12.13+\"\n          else\n            millSourcePath / \"src\" / \"main\" / \"scala-not-2.12.13+-2.13.1+\"\n        Seq(PathRef(dir))\n      } else Nil\n    val extraDir4 =\n      if (sv.startsWith(\"2.13.\") || sv.startsWith(\"3.\"))\n        Seq(PathRef(millSourcePath / \"src\" / \"main\" / \"scala-2.13-or-3\"))\n      else Nil\n    val extraDir5 =\n      if (sv.startsWith(\"3.4\"))\n        if (sv.stripPrefix(\"3.4.\").toInt < 2)\n          sys.error(\"Scala 3.4.0 and 3.4.1 are incompatible with Ammonite\")\n        else\n          Seq(PathRef(millSourcePath / \"src\" / \"main\" / \"scala-3.4.2+\"))\n      else if (sv.startsWith(\"3.3\") && sv.stripPrefix(\"3.3.\").toInt >= 2)\n        Seq(PathRef(millSourcePath / \"src\" / \"main\" / \"scala-3.3.2+\"))\n      else if (sv.startsWith(\"3\"))\n        Seq(PathRef(millSourcePath / \"src\" / \"main\" / \"scala-3.0.0-3.3.1\"))\n      else Nil\n\n    super.sources() ++ extraDir ++ extraDir2 ++ extraDir3 ++ extraDir4 ++ extraDir5\n  }\n  def externalSources = T {\n    resolveDeps(allBoundIvyDeps, sources = true)()\n  }\n  def repositoriesTask = T.task {super.repositoriesTask() ++ Seq(\n    mvn\"https://scala-ci.typesafe.com/artifactory/scala-integration\"\n  ) }\n  override implicit def crossSbtModuleResolver: mill.define.Cross.Resolver[CrossModuleBase] =\n    new mill.define.Cross.Resolver[CrossModuleBase] {\n      def resolve[V <: CrossModuleBase](c: Cross[V]): V = {\n        crossScalaVersion\n          .split('.')\n          .inits\n          .filter { v =>\n            if (isScala3(crossScalaVersion)) v.length != 2 else v.length != 1\n          }\n          .flatMap(prefix =>\n            c.items\n              .map(_.module.value)\n              .find(_.crossScalaVersion.split('.').startsWith(prefix))\n          )\n          .collectFirst { case x => x }\n          .getOrElse {\n            throw new Exception(\n              s\"Unable to find compatible cross version between $crossScalaVersion and \" +\n                c.items.map(_.module.value.crossScalaVersion).mkString(\",\")\n            )\n          }\n\n      }\n    }\n}\ntrait AmmModule extends AmmInternalModule with PublishModule {\n  def publishVersion = buildVersion\n  def pomSettings = PomSettings(\n    description = artifactName(),\n    organization = \"com.lihaoyi\",\n    url = s\"https://github.com/${ghOrg}/${ghRepo}\",\n    licenses = Seq(License.MIT),\n    versionControl = VersionControl.github(ghOrg, ghRepo),\n    developers = Seq(\n      Developer(\"lihaoyi\", \"Li Haoyi\", \"https://github.com/lihaoyi\")\n    )\n  )\n\n  def transitiveJars: T[Agg[PathRef]] = T {\n    mill.define.Target.traverse(this +: moduleDeps)(m =>\n      T.task { m.jar() }\n    )()\n  }\n\n  def transitiveSourceJars: T[Agg[PathRef]] = T {\n    mill.define.Target.traverse(this +: moduleDeps)(m =>\n      T.task { m.sourceJar() }\n    )()\n  }\n\n  override def javacOptions = Seq(\"-source\", \"1.8\", \"-target\", \"1.8\")\n}\ntrait AmmDependenciesResourceFileModule extends JavaModule {\n  def dependencyResourceFileName: String\n  def dependencyFileResources = T {\n    val deps0 = T.task { compileIvyDeps().map(bindDependency()) ++ transitiveIvyDeps() }()\n    val (_, res) = mill.modules.Jvm.resolveDependenciesMetadata(\n      repositoriesTask(),\n      deps0.map(_.dep),\n      deps0.filter(_.force).map(_.dep),\n      mapDependencies = Some(mapDependencies())\n    )\n\n    Seq(PathRef(generateDependenciesFile(\n      dependencyResourceFileName,\n      res.minDependencies.toSeq\n    )))\n  }\n\n  def resources = T.sources {\n    super.resources() ++ dependencyFileResources()\n  }\n}\n\nobject terminal extends Cross[TerminalModule](binCrossScalaVersions)\ntrait TerminalModule extends AmmModule {\n  def ivyDeps = T {\n    super.ivyDeps() ++ Agg(\n      Deps.fansi,\n      Deps.sourcecode\n    )\n  }\n  object test extends AmmTests {\n    def ivyDeps = super.ivyDeps() ++ Agg(Deps.sourcecode)\n  }\n}\n\nobject amm extends Cross[MainModule](fullCrossScalaVersions) {\n  object util extends Cross[UtilModule](binCrossScalaVersions)\n  trait UtilModule extends AmmModule {\n    def moduleDeps = Seq()\n    def ivyDeps = T {\n      super.ivyDeps() ++ Agg(\n        Deps.osLib,\n        Deps.typename,\n        Deps.scalaCollectionCompat,\n        Deps.fansi,\n        Deps.pprint\n      )\n    }\n    def compileIvyDeps = super.compileIvyDeps() ++\n      (if (isScala3(crossScalaVersion)) Agg.empty[Dep] else Agg(Deps.scalaReflect(scalaVersion())))\n  }\n\n  object runtime extends Cross[RuntimeModule](fullCrossScalaVersions)\n  trait RuntimeModule extends AmmModule {\n    def moduleDeps = Seq(amm.util(), interp.api(), amm.repl.api())\n    def isCrossFullScalaVersion = true\n    def ivyDeps = super.ivyDeps() ++ Agg(\n      Deps.classPathUtil,\n      Deps.upickle(crossScalaVersion),\n      Deps.requests,\n      Deps.mainargs,\n      Deps.coursierDependencyInterface\n    )\n  }\n\n  object compiler extends Cross[CompilerModule](fullCrossScalaVersions) {\n    object interface extends Cross[CompilerInterfaceModule](fullCrossScalaVersions)\n    trait CompilerInterfaceModule extends AmmModule {\n      def isCrossFullScalaVersion = true\n      def moduleDeps = Seq(amm.util())\n      def exposedClassPath = T {\n        runClasspath() ++\n          externalSources() ++\n          transitiveJars() ++\n          transitiveSourceJars()\n      }\n    }\n  }\n  trait CompilerModule extends AmmModule {\n    def supports3 = true\n    def moduleDeps = Seq(amm.compiler.interface(), amm.util(), amm.repl.api())\n    def isCrossFullScalaVersion = true\n    def ivyDeps = T {\n      val scalaSpecificDeps =\n        if (isScala2())\n          Agg(\n            Deps.scalaCompiler(scalaVersion()),\n            Deps.scalaparse,\n            Deps.scalaXml(scalaVersion())\n          )\n        else\n          Agg[Dep](\n            ivy\"org.scala-lang::scala3-compiler:${scalaVersion()}\",\n            ivy\"org.ow2.asm:asm:9.7\"\n          )\n      super.ivyDeps() ++ scalaSpecificDeps ++ Agg(\n        Deps.javassist,\n        Deps.javaparserCore\n      )\n    }\n\n    def exposedClassPath = T {\n      runClasspath() ++\n        externalSources() ++\n        transitiveJars() ++\n        transitiveSourceJars()\n    }\n\n    object test extends AmmTests\n  }\n\n  object interp extends Cross[InterpModule](fullCrossScalaVersions) {\n    object api extends Cross[InterpApiModule](fullCrossScalaVersions)\n    trait InterpApiModule extends AmmModule\n        with AmmDependenciesResourceFileModule {\n      def moduleDeps = Seq(amm.compiler.interface(), amm.util())\n      def isCrossFullScalaVersion = true\n      def dependencyResourceFileName = \"amm-interp-api-dependencies.txt\"\n      def ivyDeps = super.ivyDeps() ++ Agg(\n        Deps.coursierInterface\n      )\n      override def docJar = if (isScala3(crossScalaVersion)) T {\n        val outDir = T.ctx().dest\n        val javadocDir = outDir / \"javadoc\"\n        os.makeDir.all(javadocDir)\n        mill.api.Result.Success(mill.modules.Jvm.createJar(Agg(javadocDir))(outDir))\n      }\n      else super.docJar\n      def constantsSourceDir = T {\n        val dir = T.dest / \"src\"\n        val dest = dir / \"Constants.scala\"\n        val code =\n          s\"\"\"package ammonite.interp.script\n             |\n             |/** Build-time constants. Generated by mill. */\n             |object Constants {\n             |  def semanticDbVersion = \"${Deps.semanticDbScalac.dep.version}\"\n             |}\n             |\"\"\".stripMargin\n        os.write(dest, code, createFolders = true)\n        PathRef(dir)\n      }\n      override def generatedSources: T[Seq[PathRef]] =\n        super.generatedSources() ++ Seq(constantsSourceDir())\n    }\n  }\n  trait InterpModule extends AmmModule {\n    def moduleDeps = Seq(amm.util(), amm.runtime(), amm.compiler.interface())\n    def isCrossFullScalaVersion = true\n    def ivyDeps = super.ivyDeps() ++ Agg(\n      Deps.bsp4j,\n      Deps.fastparse\n    ) ++ Agg(\n      Deps.scalametaCommon\n    ).map(dep =>\n      if (isScala3(crossScalaVersion))\n        dep.withDottyCompat(crossScalaVersion)\n          // we remove transitive _2.13 dependencies from Scala 3 and\n          // then we add it back with _3\n          .exclude(\"com.lihaoyi\" -> \"sourcecode_2.13\")\n          .exclude(\"org.scala-lang.modules\" -> \"scala-collection-compat_2.13\")\n      else dep\n    ) ++ (if (isScala3(crossScalaVersion)) Agg(Deps.sourcecode, Deps.scalaCollectionCompat)\n          else Agg.empty[Dep])\n  }\n\n//  object `test-runner` extends mill.scalalib.SbtModule {\n//    def scalaVersion = \"2.12.8\"\n//    def ivyDeps = super.ivyDeps() ++ Agg(\n//      ivy\"com.lihaoyi::mill-scalalib:${sys.props(\"MILL_VERSION\")}\"\n//    )\n//  }\n\n  object repl extends Cross[ReplModule](fullCrossScalaVersions) {\n\n    object api extends Cross[ReplApiModule](fullCrossScalaVersions)\n    trait ReplApiModule extends AmmModule\n        with AmmDependenciesResourceFileModule {\n      def isCrossFullScalaVersion = true\n      def dependencyResourceFileName = \"amm-dependencies.txt\"\n      def moduleDeps = Seq(amm.util(), interp.api())\n      def ivyDeps = super.ivyDeps() ++ Agg(\n        Deps.mainargs,\n        Deps.geny\n      )\n      def compileIvyDeps = super.compileIvyDeps() ++ (if (isScala3(crossScalaVersion))\n                                                        Agg.empty[Dep]\n                                                      else Agg(Deps.scalaReflect(scalaVersion())))\n\n      def generatedSources = T {\n        Seq(PathRef(generateConstantsFile(buildVersion, bspVersion = bspVersion)))\n      }\n\n      def exposedClassPath = T {\n        amm.repl.api().runClasspath() ++\n          amm.repl.api().externalSources() ++\n          amm.repl.api().transitiveJars() ++\n          amm.repl.api().transitiveSourceJars()\n      }\n    }\n\n  }\n  trait ReplModule extends AmmModule {\n    def isCrossFullScalaVersion = true\n    def moduleDeps = Seq(\n      amm.util(),\n      amm.runtime(),\n      amm.interp(),\n      terminal(),\n      amm.compiler.interface()\n    )\n    def ivyDeps = super.ivyDeps() ++ Agg(\n      Deps.jlineTerminal,\n      Deps.jlineJna,\n      Deps.jlineReader,\n      Deps.scalaXml(scalaVersion())\n    )\n    def compileIvyDeps = super.compileIvyDeps() ++ (if (isScala3(crossScalaVersion)) Agg.empty[Dep]\n                                                    else Agg(Deps.scalaReflect(scalaVersion())))\n\n    object test extends AmmTests with AmmDependenciesResourceFileModule {\n      def crossScalaVersion = ReplModule.this.crossScalaVersion\n      def scalaVersion = ReplModule.this.scalaVersion\n      def dependencyResourceFileName = \"amm-test-dependencies.txt\"\n      def moduleDeps = super.moduleDeps ++ Seq(amm.compiler())\n\n      def thinWhitelist = T {\n        generateApiWhitelist(\n          amm.repl.api().exposedClassPath() ++\n            amm.compiler().exposedClassPath() ++\n            Seq(compile().classes) ++\n            resolveDeps(T.task { compileIvyDeps().map(bindDependency()) ++ transitiveIvyDeps() })()\n        )\n      }\n\n      def runClasspath = T {\n        super.runClasspath() ++ Agg(thinWhitelist())\n      }\n\n      def resources = T.sources {\n        (super.resources() ++\n          ReplModule.this.sources() ++\n          ReplModule.this.externalSources() ++\n          resolveDeps(T.task{ ivyDeps().map(bindDependency())}, sources = true)()).distinct\n      }\n      def ivyDeps = super.ivyDeps() ++ amm.compiler().ivyDeps() ++ Agg(\n        Deps.scalazCore\n      )\n    }\n  }\n}\n\ntrait MainModule extends AmmModule {\n\n  def isCrossFullScalaVersion = true\n\n  def mainClass = Some(\"ammonite.AmmoniteMain\")\n\n  def artifactName = \"ammonite\"\n\n  def moduleDeps = Seq(\n    terminal(),\n    amm.util(),\n    amm.runtime(),\n    amm.interp.api(),\n    amm.repl.api(),\n    amm.interp(),\n    amm.repl(),\n    amm.compiler()\n  )\n\n  def runClasspath =\n    super.runClasspath() ++\n      terminal().sources() ++\n      amm.util().sources() ++\n      amm.runtime().sources() ++\n      amm.interp.api().sources() ++\n      amm.repl.api().sources() ++\n      amm.interp().sources() ++\n      amm.repl().sources() ++\n      sources() ++\n      externalSources()\n\n  def prependShellScript = T {\n    mill.modules.Jvm.launcherUniversalScript(\n      mainClass().get,\n      Agg(\"$0\"),\n      Agg(\"%~dpnx0\"),\n      // G1 Garbage Collector is awesome https://github.com/lihaoyi/Ammonite/issues/216\n      Seq(\"-Xmx500m\", \"-XX:+UseG1GC\")\n    )\n  }\n\n  def thinWhitelist = T {\n    generateApiWhitelist(\n      amm.repl.api().exposedClassPath() ++\n        amm.compiler().exposedClassPath()\n    )\n  }\n  def localClasspath = T {\n    Seq(thinWhitelist()) ++ super.localClasspath()\n  }\n\n  def launcher = {\n    val isWindows = scala.util.Properties.isWin\n    if (isWindows)\n      T {\n        val mainClass = finalMainClass()\n        val cp = runClasspath().map(_.path)\n        val jvmOpts = forkArgs()\n        val dest = T.ctx().dest / \"run.bat\"\n\n        import coursier.launcher.{BootstrapGenerator, ClassLoaderContent, Parameters, Preamble}\n        val classLoaderContent = ClassLoaderContent.fromUrls(cp.map(_.toNIO.toUri.toASCIIString))\n        val params = Parameters.Bootstrap(Seq(classLoaderContent), mainClass)\n          .withPreamble(\n            Preamble()\n              .withKind(Preamble.Kind.Bat)\n              .withJavaOpts(jvmOpts)\n          )\n        val thread = Thread.currentThread()\n        val cl = thread.getContextClassLoader\n        try {\n          thread.setContextClassLoader(BootstrapGenerator.getClass.getClassLoader)\n          BootstrapGenerator.generate(params, dest.toNIO)\n        } finally {\n          thread.setContextClassLoader(cl)\n        }\n\n        PathRef(dest)\n      }\n    else\n      T {\n        super.launcher()\n      }\n  }\n\n  object test extends AmmTests {\n    def moduleDeps = super.moduleDeps ++ Seq(amm.compiler().test, amm.repl().test)\n    def ivyDeps = super.ivyDeps() ++ Agg(\n      Deps.scalaJava8Compat\n    )\n\n    def thinWhitelist = T {\n      generateApiWhitelist(\n        amm.repl.api().exposedClassPath() ++\n          amm.compiler().exposedClassPath() ++\n          Seq(amm.repl().test.compile().classes, compile().classes) ++\n          resolveDeps(T.task { compileIvyDeps().map(bindDependency()) ++ transitiveIvyDeps() })()\n      )\n    }\n\n    // Need to duplicate this from MainModule due to Mill not properly propagating it through\n    def runClasspath =\n      Seq(thinWhitelist()) ++\n      super.runClasspath() ++\n        terminal().sources() ++\n        amm.util().sources() ++\n        amm.runtime().sources() ++\n        amm.interp.api().sources() ++\n        amm.repl.api().sources() ++\n        amm.interp().sources() ++\n        amm.repl().sources() ++\n        sources() ++\n        externalSources()\n\n\n  }\n}\n\ndef generateApiWhitelist(replApiCp: Seq[PathRef])(implicit ctx: mill.api.Ctx.Dest) = {\n\n  val thinClasspathEntries = replApiCp.map(_.path).flatMap { cpRoot =>\n    if (os.isFile(cpRoot) && cpRoot.ext == \"jar\") {\n      val zip = new java.util.zip.ZipFile(cpRoot.toIO)\n      import collection.JavaConverters._\n      for (e <- zip.entries().asScala) yield e.getName\n    } else if (os.isDir(cpRoot)) {\n      for (sub <- os.walk(cpRoot)) yield sub.relativeTo(cpRoot).toString\n    } else if (!os.exists(cpRoot)) Nil\n    else throw new Exception(cpRoot.toString)\n  }\n  os.write(\n    ctx.dest / \"ammonite-api-whitelist.txt\",\n    thinClasspathEntries\n      .flatMap(_.stripSuffix(\"/\").split('/').inits)\n      .filter(_.nonEmpty)\n      .map(_.mkString(\"/\"))\n      .distinct\n      .mkString(\"\\n\")\n  )\n  PathRef(ctx.dest)\n}\n\nobject integration extends Cross[IntegrationModule](fullCrossScalaVersions)\ntrait IntegrationModule extends AmmInternalModule {\n  def moduleDeps = Seq(amm())\n  def ivyDeps = T {\n    super.ivyDeps() ++ (\n      if (scalaVersion().startsWith(\"2.13.\"))\n        Agg(Deps.cask)\n      else\n        Agg.empty\n    )\n  }\n  object test extends AmmTests {\n    def testLauncher = T {\n      if (scala.util.Properties.isWin)\n        amm().launcher().path.toString\n      else\n        amm().assembly().path.toString\n    }\n    def forkEnv = super.forkEnv() ++ Seq(\n      \"AMMONITE_ASSEMBLY\" -> testLauncher()\n    )\n  }\n}\n\nobject sshd extends Cross[SshdModule](fullCrossScalaVersions)\ntrait SshdModule extends AmmModule {\n  def moduleDeps = Seq(amm())\n  def isCrossFullScalaVersion = true\n  def ivyDeps = super.ivyDeps() ++ Agg(\n    // sshd-core 1.3.0 requires java8\n    Deps.sshdCore,\n    Deps.bcprovJdk15on\n  )\n  object test extends AmmTests {\n    def ivyDeps = super.ivyDeps() ++ Agg(\n      // slf4j-nop makes sshd server use logger that writes into the void\n      Deps.slf4jNop,\n      Deps.jsch,\n      Deps.scalacheck\n    )\n  }\n}\n\n/**\n * Selects all cross module instances, that match the given predicate.\n * In Mill 0.11, this can be hopefully replaced with a simple filter on the `crossValue`.\n */\ndef selectCrossPrefix[T <: mill.Cross.Module[_], V](\n    crossModule: Cross[T],\n    predicate: String => Boolean\n)(accessor: T => V): Seq[V] =\n  crossModule.items.collect {\n    case item if predicate(item.crossSegments.last) => accessor(item.module.value)\n  }\n    .tap { mods =>\n      if (mods.isEmpty) sys.error(s\"No matching cross-instances found in ${crossModule}\")\n    }\n\ndef unitTest(scalaVersion: String = \"\"): Command[Seq[(String, Seq[mill.testrunner.TestResult])]] = {\n  val binPred = (v: String) =>\n    v.startsWith(scalaVersion.split(\"[.\\\\-]\").take(if (v.startsWith(\"2\")) 2 else 1).mkString(\".\"))\n  val pred = (_: String).startsWith(scalaVersion)\n  val tests = Seq(\n    selectCrossPrefix(terminal, binPred)(_.test),\n    selectCrossPrefix(amm.repl, pred)(_.test),\n    selectCrossPrefix(amm, pred)(_.test),\n    selectCrossPrefix(sshd, pred)(_.test)\n  ).flatten\n\n  val log = T.task { T.log.outputStream.println(s\"Testing modules: ${tests.mkString(\", \")}\") }\n\n  T.command {\n    log()\n    T.traverse(tests)(_.testCached)()\n  }\n}\n\ndef integrationTest(scalaVersion: String = \"\") = T.command {\n  T.traverse(\n    selectCrossPrefix(integration, _.startsWith(scalaVersion))(_.test)\n  )(_.testCached)()\n}\n\ndef generateConstantsFile(\n    version: String = buildVersion,\n    unstableVersion: String = \"<fill-me-in-in-Constants.scala>\",\n    bspVersion: String = \"<fill-me-in-in-Constants.scala>\",\n    curlUrl: String = \"<fill-me-in-in-Constants.scala>\",\n    unstableCurlUrl: String = \"<fill-me-in-in-Constants.scala>\",\n    oldCurlUrls: Seq[(String, String)] = Nil,\n    oldUnstableCurlUrls: Seq[(String, String)] = Nil,\n    returnDirectory: Boolean = true\n)(implicit ctx: mill.api.Ctx.Dest) = {\n  val versionTxt = s\"\"\"\n    package ammonite\n    object Constants{\n      val version = \"$version\"\n      val unstableVersion = \"$unstableVersion\"\n      val bspVersion = \"$bspVersion\"\n      val curlUrl = \"$curlUrl\"\n      val unstableCurlUrl = \"$unstableCurlUrl\"\n      val oldCurlUrls = Seq[(String, String)](\n        ${oldCurlUrls.map { case (name, value) => s\"\"\" \"$name\" -> \"$value\" \"\"\" }.mkString(\",\\n\")}\n      )\n      val oldUnstableCurlUrls = Seq[(String, String)](\n        ${oldUnstableCurlUrls.map { case (name, value) => s\"\"\" \"$name\" -> \"$value\" \"\"\" }.mkString(\n      \",\\n\"\n    )}\n      )\n    }\n  \"\"\"\n  println(\"Writing Constants.scala\")\n\n  val dir = ctx.dest / \"src\"\n  os.write(dir / \"Constants.scala\", versionTxt, createFolders = true)\n  if (returnDirectory) dir\n  else dir / \"Constants.scala\"\n}\n\ndef generateDependenciesFile(fileName: String, deps: Seq[coursier.Dependency])(implicit\n    ctx: mill.api.Ctx.Dest\n) = {\n\n  val dir = ctx.dest / \"extra-resources\"\n  val dest = dir / fileName\n\n  val content = deps\n    .map { dep =>\n      (dep.module.organization.value, dep.module.name.value, dep.version)\n    }\n    .sorted\n    .map {\n      case (org, name, ver) =>\n        s\"$org:$name:$ver\"\n    }\n    .mkString(\"\\n\")\n\n  os.makeDir(dir)\n  println(s\"Writing $dest\")\n  dir.toIO.mkdirs()\n  os.write(dest, content.getBytes(\"UTF-8\"))\n\n  dir\n}\n\ndef publishExecutable() = {\n  if (!isPublishableCommit) T.command {\n    println(\"MISC COMMIT: generating executable but not publishing\")\n    T.sequence(latestAssemblies)()\n  }\n  else T.command {\n    val latestAssemblyJars = T.sequence(latestAssemblies)()\n\n    println(\"MASTER COMMIT: Creating a release\")\n    if (!unstable) {\n      requests.post(\n        s\"https://api.github.com/repos/${ghOrg}/${ghRepo}/releases\",\n        data = ujson.write(\n          ujson.Obj(\n            \"tag_name\" -> buildVersion,\n            \"name\" -> buildVersion,\n            \"body\" -> s\"${homePage}/#${buildVersion}\"\n          )\n        ),\n        headers = Seq(\"Authorization\" -> s\"token ${sys.env(\"AMMONITE_BOT_AUTH_TOKEN\")}\")\n      )\n    }\n\n    for ((version, jar) <- assemblyCrossScalaVersions.zip(latestAssemblyJars)) {\n      println(\"MASTER COMMIT: Publishing Executable for Scala \" + version)\n      // Prepare executable\n\n      val scalaBinaryVersion = version.take(version.lastIndexOf(\".\"))\n      upload(\n        uploadedFile = jar.path,\n        tagName = latestTaggedVersion,\n        uploadName = s\"$scalaBinaryVersion-$buildVersion\",\n        authKey = sys.env(\"AMMONITE_BOT_AUTH_TOKEN\"),\n        ghOrg = ghOrg,\n        ghRepo = ghRepo\n      )\n      upload(\n        uploadedFile = os.temp(\n          os.read(os.pwd / \"amm-template.sh\")\n            .replace(\"DEFAULT_AMM_VERSION=\", s\"DEFAULT_AMM_VERSION=$latestTaggedVersion\")\n            .replace(\"DEFAULT_SCALA_VERSION=\", s\"DEFAULT_SCALA_VERSION=$scalaBinaryVersion\")\n        ),\n        tagName = latestTaggedVersion,\n        uploadName = s\"$scalaBinaryVersion-$buildVersion-bootstrap\",\n        authKey = sys.env(\"AMMONITE_BOT_AUTH_TOKEN\"),\n        ghOrg = ghOrg,\n        ghRepo = ghRepo\n      )\n    }\n  }\n}\n\ndef publishDocs(skipDeploy: Boolean = false): Command[Unit] = {\n  val ammoniteAssembly = amm(scala2_13Versions.last).assembly\n  // Disable doc auto-publishing for now, as the recent modularization means we\n  // need to make significant changes to the readme and that'll time.\n  if (!isMasterCommit) T.command {\n    println(\"MISC COMMIT: Building readme for verification\")\n    try {\n      os.proc(\n        \"sbt\",\n        \"readme/run\"\n      ).call(\n        env = Map(\n          \"AMMONITE_ASSEMBLY\" -> ammoniteAssembly().path.toString,\n          \"CONSTANTS_FILE\" -> generateConstantsFile(returnDirectory = false).toString\n        )\n      )\n    } catch {\n      case e =>\n        println(e)\n        e.printStackTrace()\n        throw e\n    }\n    ()\n  }\n  else T.command {\n    println(\"MASTER COMMIT: Updating version and publishing to Github Pages\")\n\n    if (!skipDeploy) {\n      val deployKey = sys.env(\"DEPLOY_KEY\").replace(\"\\\\n\", \"\\n\")\n      os.write(os.pwd / \"deploy_key\", deployKey)\n    }\n\n    val (stableKey, unstableKey, oldStableKeys, oldUnstableKeys) =\n      if (!unstable) {\n        (\n          s\"$latestTaggedVersion/2.13-$latestTaggedVersion\",\n          s\"$latestTaggedVersion/2.13-$latestTaggedVersion\",\n          for (v <- Seq(\"2.12\"))\n            yield s\"$latestTaggedVersion/$v-$latestTaggedVersion\",\n          for (v <- Seq(\"2.12\"))\n            yield s\"$latestTaggedVersion/$v-$latestTaggedVersion\"\n        )\n      } else {\n        (\n          s\"$latestTaggedVersion/2.13-$latestTaggedVersion\",\n          s\"$latestTaggedVersion/2.13-$buildVersion\",\n          for (v <- Seq(\"2.12\"))\n            yield s\"$latestTaggedVersion/$v-$latestTaggedVersion\",\n          for (v <- Seq(\"2.12\"))\n            yield s\"$latestTaggedVersion/$v-$buildVersion\"\n        )\n      }\n    println(\"(stableKey, unstableKey)\")\n    println((stableKey, unstableKey))\n    val constantsFile = generateConstantsFile(\n      latestTaggedVersion,\n      buildVersion,\n      bspVersion,\n      s\"https://github.com/${ghOrg}/${ghRepo}/releases/download/$stableKey\",\n      s\"https://github.com/${ghOrg}/${ghRepo}/releases/download/$unstableKey\",\n      for (k <- oldStableKeys)\n        yield (k, s\"https://github.com/${ghOrg}/${ghRepo}/releases/download/$k\"),\n      for (k <- oldUnstableKeys)\n        yield (k, s\"https://github.com/${ghOrg}/${ghRepo}/releases/download/$k\"),\n      returnDirectory = false\n    )\n\n    os.proc(\n      \"sbt\",\n      \"readme/run\"\n    ).call(\n      env = Map(\n        \"AMMONITE_ASSEMBLY\" -> ammoniteAssembly().path.toString,\n        \"CONSTANTS_FILE\" -> constantsFile.toString\n      )\n    )\n    if (skipDeploy) {\n      println(\"Skip deployment\")\n    } else {\n      println(\"Deploying ...\")\n      os.proc(\"ci/deploy_master_docs.sh\").call()\n    }\n    ()\n  }\n}\n\ndef partition(\n    publishArtifacts: mill.main.Tasks[PublishModule.PublishData],\n    shard: Int,\n    divisionCount: Int\n) = {\n\n  val groupedArtifacts = publishArtifacts.value\n    .map { t =>\n      val taskCrossVersion = t.ctx.segments.value\n        .collectFirst { case mill.define.Segment.Cross(List(v)) => v }\n        .get\n\n      // Sort primarily on the scalaVersion, using the rendered name of the\n      // task as the secondary sort key to break ties and ensure determinism\n      t -> (fullCrossScalaVersions.indexOf(taskCrossVersion), t.ctx.segments.render)\n    }\n    .toMap\n\n  val sortedArtifacts = publishArtifacts.value.sortBy(groupedArtifacts)\n\n  val boundaries =\n    for (x <- 0 to divisionCount)\n      yield math.round((x.toDouble * sortedArtifacts.length) / divisionCount).toInt\n\n  sortedArtifacts.slice(boundaries(shard - 1), boundaries(shard))\n\n}\n\ndef publishSonatype(\n    publishArtifacts: mill.main.Tasks[PublishModule.PublishData],\n    shard: Int,\n    divisionCount: Int\n) =\n  T.command {\n\n    val x: Seq[(Seq[(os.Path, String)], Artifact)] = {\n      mill.define.Target.sequence(partition(publishArtifacts, shard, divisionCount))().map {\n        case PublishModule.PublishData(a, s) => (s.map { case (p, f) => (p.path, f) }, a)\n      }\n    }\n    if (isPublishableCommit)\n      new SonatypePublisher(\n        uri = \"https://oss.sonatype.org/service/local\",\n        snapshotUri = \"https://oss.sonatype.org/content/repositories/snapshots\",\n        credentials = sys.env(\"SONATYPE_DEPLOY_USER\") + \":\" + sys.env(\"SONATYPE_DEPLOY_PASSWORD\"),\n        signed = true,\n        gpgArgs = Seq(\n          \"--passphrase\",\n          sys.env(\"SONATYPE_PGP_PASSWORD\"),\n          \"--no-tty\",\n          \"--pinentry-mode\",\n          \"loopback\",\n          \"--batch\",\n          \"--yes\",\n          \"-a\",\n          \"-b\"\n        ),\n        readTimeout = 600000,\n        connectTimeout = 600000,\n        log = T.ctx().log,\n        workspace = T.workspace,\n        env = T.env,\n        awaitTimeout = 600000,\n        stagingRelease = true\n      ).publishAll(\n        true,\n        x: _*\n      )\n  }\n\n/**\n * Somethime, the Mill publish command fails although the Sonatype publishing went through.\n * This command checks, whether all artifacts are publshed.\n * Run with:\n * {{{\n * mill checkPublishedArtifacts --artifacts __.publishSelfDependency --version {version} --ttl \"1 sec\"\n * }}}\n * See also https://github.com/com-lihaoyi/Ammonite/pull/1453\n */\ndef checkPublishedArtifacts(artifacts: Tasks[Artifact], version: String, ttl: String = \"1 hour\") =\n  T.command {\n    val coords = T.sequence(artifacts.value)()\n    val next = new AtomicInteger(0)\n    val fut = coords.map { coord =>\n      Future {\n        val dep = s\"${coord.group}:${coord.id}:${version}\"\n        println(s\"[${next.incrementAndGet()}/${coords.size}] Checking ${dep}\")\n        val res = os.proc(\"cs\", \"complete-dep\", dep, \"-l\", ttl)\n          .call().out.text().trim()\n        // println(res)\n        Option.when(!res.contains(version))(dep)\n      }(ExecutionContext.global)\n    }\n    val missing = fut.map(Await.result(_, duration.Duration.Inf)).flatten\n    if (missing.isEmpty) {\n      Result.Success(s\"All artifacts published for version ${version}\")\n    } else {\n      val msg =\n        if (missing.size == coords.size) s\"All artifacts missing for version ${version}\"\n        else s\"Missing ${missing.size} of ${coords.size} published artifacts: ${\n            missing.mkString(\"\\n- \", \"\\n- \", \"\")\n          }\"\n      Result.Failure(msg)\n    }\n  }\n"
            ]
        ],
        "repos": [],
        "ivyDeps": [
            "com.lihaoyi::mill-contrib-bloop:$MILL_VERSION",
            "io.get-coursier::coursier-launcher:2.1.0-RC1"
        ],
        "importGraphEdges": [
            [
                "/home/runner/work/Ammonite/Ammonite/ci/upload.sc",
                []
            ],
            [
                "/home/runner/work/Ammonite/Ammonite/build.sc",
                [
                    "/home/runner/work/Ammonite/Ammonite/ci/upload.sc"
                ]
            ]
        ],
        "errors": [],
        "millImport": false
    },
    "valueHash": 668616162,
    "inputsHash": -1619601770
}